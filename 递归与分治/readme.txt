equationCount.c

整数划分问题：

f(n,m)即最大加数不大于m的n划分个数，则：
 (1)当n=1时，不论m的值为多少（m>0)，只有一种划分即{1};
 (2)当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,...,1};
 (3)当n=m时，根据划分中是否包含n，可以分为两种情况：
    (a)划分中包含n的情况，只有一个即{n}；
    (b)划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分，因此 f(n,n) =1 + f(n,n-1);
 (4)当n<m时，由于划分中不可能出现负数，因此就相当于f(n,n);
 (5)但n>m时，根据划分中是否包含最大值m，可以分为两种情况：
    (a)划分中包含m的情况，即{m, {x1,x2,...xi}}, 其中{x1,x2,... xi} 的和为n-m，因此这情况下为f(n-m,m)
    (b)划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1)，因此 f(n, m) = f(n-m, m)+f(n,m-1);
 综上所述：
                             f(n, m)=   1;              (n=1 or m=1)
               f(n,m)   =    f(n, n);                   (n<m)
                             1+ f(n, m-1);              (n=m)
                             f(n-m,m)+f(n,m-1);         (n>m)



chessBoard.cpp

棋盘覆盖问题：

问题描述：

http://blog.chinaunix.net/uid-26548237-id-3505163.html

问题解决：

将2^k * 2^k的棋盘，先分成相等的四块子棋盘，其中特殊方格位于四个中的一个，构造剩下没特殊方格的三个字棋盘，将它们中的也假设一个方格为特殊方格。如果是：

    左上角的子棋盘（若不存在特殊方格）：则将该子棋盘右下角的那个方格假设为特殊方格；
    右上角的子棋盘（若不存在特殊方格）：则将该子棋盘左下角的那个方格假设为特殊方格；
    左下角的子棋盘（若不存在特殊方格）：则将该子棋盘右上角的那个方格假设为特殊方格；
    右下角的子棋盘（若不存在特殊方格）：则将该子棋盘左上角的那个方格假设为特殊方格；

    当然，上面四种情况，只可能且必定只有三种成立，那三个假设的特殊方格刚好构成一个L型骨牌，我们可以给它们作上相同的标志。这样四个子棋盘就分别都和原来的大棋盘类似，我们就可以用递归的算法解决了。





mergeSort.cpp  

归并排序问题（归并即递归地分解数列再合并数列即可）

问题分析：

首先考虑下如何将将二个有序数列合并，用一个函数实现即可。


解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便

的将这二组数据进行排序。如何让这二组组内数据有序了？


可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就

可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。